[{"title":"【linux】在没有root权限电脑安装编译后的python","date":"2025-05-15T08:54:48.000Z","url":"/2025/05/15/linux-without-root-ssl/","tags":[["python","/tags/python/"],["linux","/tags/linux/"],["openssl","/tags/openssl/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"为什么会出这个呢，因为当前工作碰到了，顺道记录一下解决方案 问题情况 没有root权限 自带的python或者已经装好的python或者conda 都不能装包或者下载东西，一直提示443异常 单独运行python代码会提示以下内容 问题剖析 openssl版本过低 python编译的时候没有链接到openssl 大概解决思路 要么安装比较低版本的python 要么重新编译python 解决我这里选择重新编译，因为没有root权限，所以下面的操作都在用户目录下～ 1. 下载openssl我这里选择python3.10版本，所以我这里的openssl至少得要1.1.1版本，其他的版本自行搜索处理 操作完了之后，输入 2. 下载python直接去官网下载你的python xz或者tar的都可以，先解压好 3. 验证 只要上面没有报错就可以了"},{"title":"【linux】磁盘挂载相关问题","date":"2025-01-09T07:59:06.000Z","url":"/2025/01/09/linux-rom/","tags":[["docker","/tags/docker/"],["linux","/tags/linux/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"记录一下在ubuntu中遇到的一些问题及相关的解决方法 ：root 登陆； 磁盘挂载 一、root权限因为有些操作老是输入 sudo 很麻烦，所以我们最好还是像 centos 之类的默认就是root劝降来的舒服，首先我们进入账号 给root账号创建密码 设置root账号的密码 然后输入并确认root账号的密码，可能会问你要密码先，如果没有配置的话，大概率是和你当前账号一样的密码 允许 root用户通过ssh登陆 然后我们输入 ? 然后输入 PermitRoot 直接回车 然后按 n 切换下一个匹配，找到这一行，我这里是改过的，如果没有改的话，这里应该是 PermitRootLogin prohibit-password 如果是 yes 那么忽略 如果是 PermitRootLogin prohibit-password 就改成我图中的 yes 在vim里面 可以用 (a i o或者其大写做一些插入，新手的话 直接用 i 就好了) 然后进入插入模式，然后按 end挪光标到末尾，删除prohibit-password 然后改成 yes 最后按ESC 退出插入模式 然后按 : 进入编辑模式 输入 wq 保存退出 重启 SSH 服务 然后接下来我们就可以用 root 账号进行登陆了 二、挂载磁盘 走到这里，下面所有的内容我默认是root权限下运行的了，如果你不是，自己在命令前加 sudo ,下面截图均为示例 1. 查看磁盘信息 可以看到并没有挂载磁盘或者说没有我们目标中的~大磁盘 然后我们查看一下磁盘的信息 看到我们有一个4T的盘没有挂载，如上示例 nveme0n1 即是我们要的盘 如果已经挂载了会有如下情况,下面两个情况都是已经创建了分区 2. 分区管理2.1 如果已经有分区 - 删除(可选) 可选–我们可以删除分区（不一定要实现这个操作啊） 操作完之后 磁盘就是如下情况 2.2 没有分区(可选) 创建分区 出来输入行后先输入n 即 new 创建分区 后续操作后我们全部默认即可，然后输入 w退出，如下 操作完之后可以输入lsblk 查看一下 注意这里，可能有的时候默认是2T，根据情况自己操作 如下情况 这个是因为磁盘的分区格式问题 之前是 MBR分区，所以我们可以转成GPT分区，这样子可以挂载更大的空间容量 2.3更改分区格式（可选）操作如下：我们先按照上面的流程，先删除磁盘的分区，然后我们 使用 parted工具将磁盘格式化为GPT 进入交互页面后输入 然后输入 yes 然后输入 quit 退出 然后我们就可以 继续上面2.2的流程 挂载全盘了(就是重新操作一遍) 3.格式化分区 格式化为文件系统（ext4） 创建挂载点 挂载分区 - 临时挂载分区以验证： 验证是否挂载成功 如果出现了如下情况，就是成功了 4. 配置开机自动挂载因为上面是临时挂载，如果电脑重启了，那么就还需要手动挂载一次，所以为了方便，我们都要进行一下开机自动挂载 获取UUID 输入之后会出现如下情况 /dev/nvme0n1p1: UUID=&quot;1234-ABCD&quot; TYPE=&quot;ext4&quot; ... 我们复制UUID的内容 拼接这个字符串,后面粘贴进fs的文件 打开文件 然后我们刚才组合好的字符串放到文件后面就好了(这里的操作就不教了) 如下 保存退出， 3.校验 如果上面的命令，没有报错，则挂载配置完成 额外信息下面的内容和本文关系不大只是用作记录备份方便后面查看 docker 更改镜像下载目录因为我们现在有很大的空间了，我们可以把docker的镜像啥的东西搞到我们新弄的磁盘下面了 停止docker（可选，不停也没关系） 创建数据挂载磁盘 编辑docker的配置文件 把下面的内容贴进去 重启docker服务 校验是否成功 到此 docker的镜像下载目录就替换成功了 "},{"title":"【https】原来自己签https网站这么简单","date":"2024-04-09T15:44:33.000Z","url":"/2024/04/09/https-write/","tags":[["ssl","/tags/ssl/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"自己签https证书 很多时候我们访问一些http的网站，浏览器总是会提示我们不安全。我们自己搭建一个博客，由于买不起高贵的ssl证书费用，所以我们大多数时候都是裸奔的http。 今天，我们自己来签，免费的 https 准备工作 有服务器 有域名 工具我们采用的 Let’s Encrypt - 免费的SSL&#x2F;TLS证书 (letsencrypt.org) 这个网站里面的工具，但是里面的东西晦涩难懂，所以我这里直接就讲干的。 步骤 安装 snapd 工具，后续无脑安装：这个我用的centos，直接yum install snapd 确保你没有安装过旧版的 certbot:如果安装了，试试下面的删除方式 sudo apt-get remove certbot sudo dnf remove certbot sudo yum remove certbot 然后我们用snapd工具安装certbot 安装好了之后绑定一下软连接 然后就可以直接一键操作了，因为我用的nginx，并且之前没有https，所以我直接一键操作 操作之前可以先备份一下原始的nginx配置文件，以防万一 当然也可以只生成证书 我是无脑操作，操作中会提示你输入一些选项，会自动识别你nginx配置的域名，根据提示操作即可 有上面的提示后，就签名成功了，注意你要用https ，你的服务器**安全组(防火墙)**，一定要把443端口对外开放 测试浏览器直接访问你自己的域名，https访问通过即成功 续签官方推荐以下操作续签 可以把上面的指令写进crontab 里面每天更新一下,如下： "},{"title":"【windows】永久关闭这个烦人的自动更新","date":"2023-11-20T09:50:08.000Z","url":"/2023/11/20/closeWindowsUpdate/","tags":[["windows","/tags/windows/"],["系统","/tags/%E7%B3%BB%E7%BB%9F/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"是否已经厌烦了windows个人版经常自动更新，这个文章就是为了解决这个事！ 一、为啥？个人版的系统经常自动升级，本来好好的，挂了一些东西运行，但是，老是自动更新，然后还关闭不掉。那么下面是互联网上总结的一些经验 二、关闭这些首先我们打开终端，这个开启方法很多，为了照顾很多非程序员的人，所以我会给很多示例，随便选一个就好了，我们今天要操作的事情，和终端的内容显示的没有关系，每个人的可能不一样，不过没有关系，我们输入的命令一样就好了~ 0.打开终端 开启终端，任选其一 如果你有这个搜索窗口，或者是一个 放大镜的图标在任务栏，点一下，有个搜索，输入cmd 回车就好了。 这个是win11的位置，一样的其实，就是打开了 开始菜单后往上面输入cmd即可 随便打开一个资源目录文件夹，点击上面的 地址栏，然后这里输入cmd也可以 或者任意位置，按住shift不放，然后右键鼠标，会出来一个选项，我们点击 – 在此处打开 Powershell 窗口，这个窗口样式和cmd的不太一样，但是和我们要进行的不影响 会开的人员随意 下面的命令，输入了之后，可能要等一段时间才会弹出来窗口，每个人的电脑性能不一样，耐心等一下~ 1. services.msc终端输入 services.msc 在打开的窗口里面找到以下名称的东西： 上面是未关闭的状态，我们要关闭这里！双击打开！ 服务状态：点击停止 &gt;&gt; 保证状态是 已停止 启动类型：改成禁用 操作完了先应用一下，然后点击上面的恢复,把第一次失败改成 无操作，然后应用之后确定退出 除了终端，弹出来的关闭，这一步完成 2. gpedit.msc 终端输入 gpedit.msc 在组策略编辑器中里面找到以下名称的东西：依次展开 计算机配置 -&gt; 管理模板 -&gt; Windows组件 -&gt; Windows更新 双击 配置自动更新 选择 已禁用 -&gt; 确定 双击删除使用所有Windows更新功能的访问权限 选择 已启用 -&gt; 确定 除了终端，弹出来的关闭，这一步完成 3. taskschd.msc 终端输入 taskschd.msc 在任务计划程序的设置界面，依次展开 任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate 右边这个窗口里面，每个人的是不一样，右键选择 &gt; 禁用 &lt; 把能关闭的都关闭就好了，有的可能关闭不了，不用管就好了 除了终端，弹出来的关闭，这一步完成 4. regedit 终端输入 regedit 有的人可能会弹出来这个，选择 是 我们找到以下路径: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc 点击一下，我们看到右边会这样子显示： 双击 Start 在弹出来的窗口:把数值改成 4 双击FailureActions:弹出来的窗口把图中左边对应的10和18位置 ：这两右边圈主的第五组数字，原来是 两个 01 改成00 记得改了的都要确定保存哦 好了，就这四个改了就好了，然后该关了的都可以关了~"},{"title":"【Jupyter】搭配nginx可能出现问题食用方法","date":"2023-11-10T15:17:52.000Z","url":"/2023/11/10/nginx-jupyterlab/","tags":[["jupyter","/tags/jupyter/"],["nginx","/tags/nginx/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"本篇虽然讲的是jupyterlab出现的问题，但是核心和jupyter是相关的 大概问题 以下问题基本上只会在你用nginx代理服务器的时候jupyterlab会出现的问题 1. 打不开内部的终端这个问题是因为，没有在nginx配置文件里面配置wss相关的属性，所以不能访问。如下修改即可 2. 插件异常后续异常的时候解决 留一句话真的很好用 Jupyterlab 可以研究一下的"},{"title":"【打包】简述几种源码打包工具","date":"2023-05-11T08:10:45.000Z","url":"/2023/05/11/pythonpackages/","tags":[["python","/tags/python/"]],"categories":[["摘要","/categories/%E6%91%98%E8%A6%81/"]],"content":"本文讲的是的 python源码打包成 whl 或者 tar.gz 之类的 而不是 exe哈 setuptools最早的时候我们均按照这个东西，详细的东西就不说了，我就按照我的 lite-tools 的打包参数来说好了 setup.py 上面的内容我是移除了一些内容，但是整体流程就是写一个这样的文件，后面我们在命令行执行下面的操作就可以打包文件到 dist 目录下了 pyproject.toml这个只是一个文件，告诉构建工具该怎么做而已，这是最新的python 推荐使用的方式，我这里 先手动创建一个，后面有工具可以自己生成，但是我这里得先讲一下手动创建的这个步骤。 这个文件是放在之前放setup.py的那个目录层级的，现在我们不需要用setup.py来管理这个打包了。 现在我们是推荐用 setup.cfg 来配置，这个文件和 setup.py里面的内容很相似，基本都能找到对应的字段。可以写什么字段可以点击这里查看详细文档。 我下面把我现在写的 部分 配置贴出来：注意，没有引号。 (我下面内容还是删除了很多，实际这些内容点前面的详细文档里面有更详细的写法) 现在，我们有了pyproject.toml 和 setup.cfg 两个文件了，我们该怎么打包呢。 我们现在用工具一 build， 我们首先需要 pip install --upgrade build 然后 它会自动去根据 pyproject.toml 和 setup.cfg 打包。 这个工具在windows可能会出现一些问题，我下面是因为有些描述文档有中文，我cfg文件里面有读取，导致异常了。 然后我换了一个linux系统: wsl 就可以顺利执行了。 poetry这个工具也可以，我这里不讲了，自己网上搜 Poetry - Python dependency management and packaging made easy (python-poetry.org) flit这个是一个更加方便的python打包工具，和上面poetry类似，根据自己喜好即可。Flit 3.8.0 — Flit 3.8.0 documentation (pypa.io)"},{"title":"【pyenv】python版本管理神器","date":"2023-03-31T09:19:00.000Z","url":"/2023/03/31/pyenv/","tags":[["python","/tags/python/"],["pyenv","/tags/pyenv/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"距离上一次写文章已经很久过去了，主要是工作繁忙，我想写的东西比较花时间，但是今天【20230331】写这个是比较简短的，耗时很少，但是确实有用。 所以到这个时间点，我工具均用最新版进行讲解，其中有一些问题也可以说出来避免踩坑~ 一、这是什么我们平时在开发东西的时候，都听说过虚拟环境，这样子可以让我们需要开发的东西所使用的包版本什么的是和我们日常使用的相互隔离，不会出现兼容问题。但是这个东西有个问题就是，大多情况下，我们都是同一个python，不能保证在其它版本python也能完美运行，所以就有了接下来我要说的这个神器—-pyenv。 1. 说明我这里会有很多特殊情况，如果你的网络好，或者有梯子之类的工具，可以按照官方的教程，但是这里得注意一个点，pyenv 这个工具在windows 和 linux&#x2F;mac 需要安装的是不一样的东西。 下面是我贴出来的官方的链接 window: 点这里 linux: 点这里 macos: 和linux一样的，官方也推荐使用homebrew homebrew： mac 上面一个软件包管理神器，推荐使用，如果网络好可以参考这里,不好也可以用国内源，这里给一篇不错的教程 【如果是mac通过homebrew安装 或者linux通过官方安装的 不用考虑兼容问题，测试完美运行，尤其你用的是windows需要注意后面问题】如果要用pyenv，电脑上最好别用官方的python了，我们都用这个了，就可以更方便管理了。主要是环境变量里面如果还有系统自带的python那么可能会有一些问题，后面会说。 2. 安装我们上面已经给出了基于官方的链接的安装地址，可以看里面的操作，一键安装。但是对于我们国内的用户来说，可能就没有那么轻松了。 2.1 mac我们已经基于第一点说了那个homebrew，并且按照教程配置了国内源。所以这里安装就很轻松。 如果安装的时候报错了,可以输入brew version 会提示你有两个命令，复制粘贴一下就好了。 2.2 linux这里我教两个方案，网上都是按照官方的，可能会没有网络连接不上。 方案一：把 转移到gitee ，然后替换成gitee你设置的仓库地址就好了，下面是一个我复制别人转移好的仓库的示例，比较新(20230326迁移的，我看了一下这个仓库是持续维护的，后面pyenv-virtualenv 也是这个用户维护的，可以直接用) 方案二： 手动直接下载下来，手动把zip文件解压到 ~/.pyenv 这个目录 文件放到了~/.pyenv 目录下后，我们需要编译一下，直接按照官方教程 然后我们需要添加一下系统环境变量，下面两点根据你的终端类型选择。 对于bash 对于zsh 弄完了之后，需要重启一下shell 2.3 windows这个地方和linux/macos的包是不一样的，我们可以在官方下载，也可以通过我们已有的python的pip来安装，下面的home可以是你任意目录，不写的话默认是在你windows主用户目录下。当然也可以安装好了剪切到你想要放的目录，然后按照下面的添加环境变量就好了。 然后我们需要去系统设置一下环境变量，我这里就不教命令行了，如果想用命令行也可以，但是大概率还得去系统设置里面调整一下顺序。 首先先在系统变量里面添加一个pyenv的root变量 我的是这个情况 然后就是配置下面两个东西，我这个地方是把这俩往前面移动了 然后我把我之前安装的python的环境变量给移除了，不移除也可以，但是为了避免可能出现的如下情况，下面是特殊情况的示例： 我系统是安装了3.10.8版本的普通python，然后切换了pyenv版本后替换不过去,因为我把python的环境变量顺序放在了pyenv的环境变量之前。我就想着我本来就要用pyenv管理python的，所以我就移除了之前的那个系统变量。 现在我弄好了情况如下： 二、可能异常1. 建议安装因为有些包有什么版本问题啥的，所以这里建议先安装这些东西再进行下面的操作。 1.1 macos需要安装Xcode Command Line Tools和Homebrew Homebrew 在前面已经讲了，点击这里跳转 1.2 linuxUbuntu&#x2F;Debian Fedora&#x2F;Centos&#x2F;RHEL 2. 安装python 这里一般都是网络的问题，要么替换国内源，要么就去下面下载离线镜像，python官网也可以下载，就看你了。 官方的情况如下： 我们下载好了离线包之后，把包复制到.pyenv下面的目录 windows –&gt; 你的目录\\.pyenv\\pyenv-win\\install_cache 这个目录下，把从你下载的python丢这里 mac&#x2F;linux –&gt; 你的目录\\.pyenv\\cache (这个cache目录可能不存在，需要手动在这里创建一下)，然后可以直接在这个目录执行你想要下载的python版本，示例: 然后我们就可以去命令行执行安装这个指定版本的python了 安装的过程会比较久~ 耐心等待 对自己网络自信的可以输入下面指令查看可以安装的python版本 三、教程1. 插件这是一个虚拟环境插件，不过这个只适用于 linux&#x2F;mac，windows这个属于另类，没有官方插件（主要是开发者大佬说兼容windows浪费时间，他又不用windows），但是可以用其它工具实现，道理一样的。 mac用户通过 homebrew轻松安装 linux 可以参考 官方，同理网络不好也可以用国内镜像 然后其他的按照官方弄，我这里不讲了 插件安装完了之后，输入 pyenv 会发现多了一些东西 没安装的时候 安装完了之后 这里怎么使用也很简单的啦，后面轻度教学，核心使用直接看官方git下面~ 2. 命令主要列举了常用的一些，还有很多不常用的或者不同系统不兼容的就算了 1.0 直接pyenv 1.1 help 我把这个放在第一个，就是因为不懂得可以在这里输入看看教程 1.2 设置版本我这里主要是为了把三个放一起，因为这三个是效果类似的，但是有差别， global: 就是把某个python设置为全局使用的，就是你在哪儿打开都是这个版本的，我目前是喜欢用python3.10 所以我就设置了这个 本来上面会有一个system 的选项的，因为我不想用了，移除了就没有了 直接把已经安装好的python版本操作如下： shell: 这是给当前shell环境临时使用python版本，关掉了就恢复。 pyenv shell --unset 可以立即取消。 local: 这里给当前目录设置python版本，包括子目录。你下次打开就会默认这个版本python。在指定目录输入后，你会发现你的目录里面多了一个文件。这个地方就会一直用这个版本。 pyenv local --unset 取消本地的设置 1.2 version 查看当前正在使用的python版本。 1.3 versions 查看已经安装好了的python版本信息 1.4 install 如果网络不好，可以离线安装python，详细看前面，点这里跳转。 1.5 uninstall 卸载指定版本的python 1.6 rehash 按道理来说 安装了新版本后都应该执行以下，不过新版的好像移除了这个，但是如果命名行相关工具出问题了，请记得输入这个一般可以恢复 1.7 shims 列出当前存在的shims（pyenv的工作原理就是在一个叫shims的目录下创建Python解释器的“假版本”，寻找Python应用时先从该目录查找）,这也是前面我们添加环境变量的时候需要添加一个这个的原因。 1.8 which 列举出这个环境下可执行文件的绝对路径。 1.9 virtualenv这个是linux&#x2F;macos安装了插件有的操作，windows得用其它pip安装的包实现。 1.10 更多其实还有很多指令，但是不常用，也不兼容，不过linux&#x2F;macos是完全体，所以很多在windows上没有的。不过又不常用我就不写了。 3. 更新pyenv因为我们的pyenv 是通过git clone的，所以我们只需要进入 .pyenv的目录下执行 "},{"title":"【wsl】在windows的linux子系统问题整体","date":"2023-03-02T03:20:03.000Z","url":"/2023/03/02/wslsolve/","tags":[["wsl","/tags/wsl/"]],"categories":[["摘要","/categories/%E6%91%98%E8%A6%81/"]],"content":"持续更新~ 一、安装时1. 无法安装wsl 可能需要开启下面的东西 这里的两个选项可以先勾上，如果测试不行我们再打开 Hyper-V, 我这个电脑安装的时候提示需要开启Hypter-V 然后我打开了就可以实现安装了，就没有勾选下面这两个服务测试。 可能需要开启 hyper-v 2. 没有centos在微软应用商店是没有centos的wsl镜像的，这时候我们可以去 下载地址 这里下载centos的镜像 当然新版本的镜像哪些我们可能需要切换到wsl2 设置wsl版本 查看wsl信息 下载完毕后，放在你要放的地方，然后解压出来，用管理员权限打开 CentOS*.exe 这个安装上系统就好了，安装完成了后会退出一下，然后在安装目录或者cmd输入wsl进入linux系统。当然更加方便的就是使用WindowsTerminal 一键直达~ 二、运行时1. 无网络我们刚进入linux系统的时候，可以更新一下yum 或者 apt 源 这里有个问题，网上找到的教程里面都是去更换 /etc/yum.repos.d/ 里面的信息，然后 yum makecache 之类的，但是你会发现部分版本并没有那个文件(可能不在，如果在按照网络上的操作即可) 手动修改三个文件： 注意我这里是Centos8 如果其他版本自己网上查询 国内源我这里提供两个任选其一即可 **注释掉 ** mirrorlist= 替换 baseurl= CentOS-Linux-AppStream.repo CentOS-Linux-BaseOS.repo CentOS-Linux-Extras.repo 下面是示例，三个文件是一样的，所以我展示一个 都弄完了试试下面，如果卡住不行的话，那么就得操作其它方法了 如果上面设置了还不起作用，那么就用下面这个万能的方法： 2. 设置代理首先你的windows 得有代理： 我这个主机开启的是 sock5 的代理，开启的局域网端口是19876 操作这个之前 我们得去windows的防火墙位置设置 入站规则: 控制面板 –&gt; 系统和安全 –&gt; Windows Defender 防火墙 –&gt; 高级设置 –&gt; 入站规则 –&gt; (右边)新建规则 –&gt; (选择)端口 –&gt; 特定本地端口: (输入) 你要开启的端口，可以多开几个后面http服务啥的用 我开了如下80,6666,8888,8080,8000,9999,19876 编辑 ~/.bashrc 因为我没有安装zsh 所以就改这个文件 或者 /etc/profile 写完了后记得操作保存一下 测试 如果都没有问题的话，那么在安装源啥的国内网络不行的情况下，我们可以直接开启代理下载更新。 3. 端口访问我们有些时候需要部署一些服务在linux里面，然后外面想测试，自己电脑是肯定可以访问到的127.0.0.1 或者linux的内网ip 都可以，但是我要给局域网里面的其他人访问，那么就需要操作一下了 首先保证我们的服务的端口是在windows防火墙那里配置通过了的，就是上面设置代理那里，因为我默认开启了一堆端口，所以我后面的服务可以通过这些端口访问，当然如果你要部署一个nginx在linux里面转发，那就只需要开启一个对外端口即可 开启windows防火墙端口 在windows用管理员权限打开终端 创建和删除映射 创建映射: netsh interface portproxy add v4tov4 listenport=win监听端口 listenaddress=0.0.0.0 connectport=wsl的端口 connectaddress=wsl内网ip 删除映射: netsh interface portproxy delete v4tov4 listenport=映射的端口 listenaddress=0.0.0.0 查看端口映射配置 netsh interface portproxy show all 这样子内网就可以愉快的访问你的服务器对应端口了。 注意 因为每次重启电脑，linux的内网ip会改变，所以上面的操作需要随时删除和创建 注意防火墙端口得开 4. 无systemctl网上的解决办法基本都是安装下面的东西 但是这个只是一个服务来的，上面执行了后，重启又不行了，所以我们可以开启自启动 测试 启动docker ok！ "},{"title":"【yaml】go里面两种yaml文件读取比较","date":"2023-02-22T01:47:17.000Z","url":"/2023/02/22/goyamlRead/","tags":[["go","/tags/go/"],["yaml","/tags/yaml/"]],"categories":[["摘要","/categories/%E6%91%98%E8%A6%81/"]],"content":"前言我们平时读取配置文件大多都是json, ini, conf, yaml ... 这一些文件，各有各的方便之处。现在我这里浅浅的记录一下go 语言读取yaml文件。 这个文章只讲 读取 文件 的demo 首先我这里会说到两种方案，和网上的基本其它教程一样的： gopkg.in/yaml.v3 github.com/spf13/viper 现在我们简单说一下我这里的目录结构 这个测试的配置文件 yaml.v3这个包是谷歌官方推荐的，很快，不一定方便。 安装 用这个包，我们得已知目录结构，然后创建映射关系。 代码 因为这个后面读取内容和普通的变量属性操作没有任何差别，这里不再赘述。 viper 安装 这个在读取一般文件的时候非常方便，然后可以读取各种类型的配置文件，如果不配置后面的一个文件格式的属性，那么就会按照优先级依次读取。 优先级如下: 也就是如果如果配置文件格式那里不写格式，同一个目录下有 config.json 和config.yaml 那么会优先读取json 格式的。 代码 这个包整体模板都差不多的，我这里先写一个基础格式 然后细说后面的一些操作 然后基本的键值对提取数据很简单，按照我这模板只需要如下写都可以 到目前来都很简单，这也是大多数配置文件这样子写的，但是我这例子里面有一个嵌套的二维数组，我这里尝试提取 more[0][1] 的数据。这里才是我这里要讲的核心点。 这里我们先尝试获取more 的数据查看一下类型及结果 所以可以说获取到了是一个 接口的集合值，我们现在需要对它进行遍历一下 可以看到我们运行了一次后 里面还有一层 但是是 reflect.Value 类型的，我们最终其实是想要里面的数据 比如我们设置成 int类型的 所以我们这里最好得创建一个变量来接收这个结果 每一个 reflect.Value 属性的值都会有Interface() 的方法，然后就可以转换成想要的结果 我们这里数组默认是int 。我们要是后面不跟着.(int)，那么这个val是不可以给res赋值过去的，因为它会说 我们这个Interface() 返回的结果类型是Any ，不是int 。 虽然我们单个取值查看类型Interface() 返回的就是int ，但是我们如果要给其它res使用，这里就得指定一下，它返回的就是int。所以才不会有什么问题的。 所以我们这里一定要转换一下 然后就可以提取想要的结果了 总结效率来说yaml.v3 运行效率很高，启动没有那么快，操作便捷性一般。github viper 这个只要不搞我上面比较复杂的那种数组读取之类的，还是很简单的，也可以赋值给已经创建好了的结构体，也可以上手即用，运行效率比yaml.v3 慢一丢丢，但是好用啊，比如我这里只是读取操作，这个东西写起来也很方便，但是我这里就不用了，因为一般的配置文件都是我们外面写好的，就不赘述了，写的自己去查官网啥的。 github"},{"title":"【gRPC】师傅领进门，修仙靠个人","date":"2023-02-17T09:21:35.000Z","url":"/2023/02/17/gogrpc/","tags":[["go","/tags/go/"],["grpc","/tags/grpc/"],["TLS","/tags/TLS/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"gRPC入门实战 一、基本介绍1. 应用场景我们先来简单的看一下 微服务 单体架构： 一旦某个服务宕机，会引起整个应用不可用，隔离性差。 只能整体应用进行伸缩，浪费资源，可伸缩性差。 代码耦合在一起，可维护性差。 微服务架构: 解决了单体架构的弊端，但是引入了新的问题： 代码冗余 服务和服务之前存在调用关系。 服务拆分后，服务和服务之间发生的是进程和进程之前的调用，服务器和服务器之间的调用。 那么就需要发起网络调用，可能第一时间想起来的都是http 协议调用，大多微服务架构中，http虽然便捷方便，但是性能较低，这时候需要引入RPC，通过自定义协议发起TCP调用，加快传输效率。 2.过程实际rpc是客户端与服务端沟通的过程 客户端发送数据（以字节流的方式） 服务端接收并解析。根据约定知道要执行什么，然后把结果返回给客户。 RPC: 实际就是将上面过程封装一下，使其操作更加优化。 使用一些大家都认可的协议，使其规范化。 做成一些框架，直接或间接产生利益。 gRPC是一个高性能的、开源的通用RPC框架。 二、开始应用1. protobuf我们学习 gRPC需要使用Protocol Buffss 传输数据，这是谷歌搞得一套的数据结构序列化机制。 序列化: 将数据结构或对象转换成二进制串的过程。 反序列化: 将在序列化过程中所产生的二进制串转换成数据结构或者对象的过程。 protobuf的优势: 序列化后体积相比JSON和XML都小，适合网络传输 支持跨平台多语言 消息格式升级和兼容新不错 序列化和反序列化速度很快 1.1 proto文件介绍 message protobuf 中定义一个消息类型式是通过关键字 message字段指定的。 消息就是需要传输的数据格式的定义 message 关键字相当于 Cpp&#x2F;Java&#x2F;Python里面的class, go里面的struct 在消息中承载的数据分别对应于每一个字段，其中每个字段都有一个名字和一种类型，一个proto文件中可以定义多个消息类型。 字段规则 required : protobuf2 中消息体必填字段，不设置会导致编码异常，不过在protobuf3 里面被删除。 optional : 消息体重可选字段，protobuf3 里面没有required，optional等说明关键字，都默认optional。 repeated : 消息体中可重复字段，重复的值的顺序会被保留在go中重复的会被定义为切片。 消息号 在消息体的的定义中，每个字段都必须要有一个唯一的标识号，标识号是[1, 2^29 -1]范围内的一个整数。 嵌套消息 可以在其它消息类型中定义，使用消息类型，在下面的例子中，person消息就定在PersonInfo消息内: 如果要在它的父消息类型的外部重用这个消息类型，可以按照如下方式操作: 服务定义 如果想要将消息类型用在PRC系统中，可以在 .proto文件中顶一个rpc服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。 上诉代表表示，定义了一个RPC服务，该方法接收SearchRequest返回SearchResponse。 1.2 安装protobuf官方地址: 点击找到Releases 下载想要的版本，下载下来是一个压缩包，把里面东西解压出来然后放到环境变量里面. 配置好了后重新打开终端输入 protoc 看一下是否正常即可。 1.3 安装gprc 这里执行如果报如下错误，那么就是需要在项目目录下执行 然后我们在学习的目录下执行下面操作： 就可以正常执行了~ 1.4 代码生成工具上面我们安装了protocol的编译器，还有安装了核心库。我们在golang里面还需要执行以下俩操作: 其实: 上面两个文件在安装grpc的时候已经下载了，只不过还没有安装，所以我们这里需要执行的是install 命令而不是get 。执行了之后这些东西都会在GOPATH/bin目录下面可以检查一下。 1.5 写一下先直接看语法demo，这个东西并不是具体的数据，而是一个约束。 我们现在在目录下创建几个文件夹和文件，目录结构如下： 然后我们上面贴出的proto代码就是我们在hello-server里面写的内容。 接下来我们去往hello-server/proto目录下执行下面两条命令 然后会给我们生成两个go代码在当前目录; 我们可以直接在生成的代码里面找到对应的方法然后实现我们要做的事情。 上面我们弄得东西是放在hello-server里面的，我们可以整体拷贝这个proto目录到hello-client ，代码是一样的，主要是里面的一些小东西调整，因为我们约束一致。 2. 服务端编写 创建gPRC Server对象，理解为Server端的抽象对象 将server （其包含的需要被调用的服务端接口）注册到gRPC Server 的内部注册中心 这样可以在接收到请求时，通过内部的服务发现，发现该服务端接口并转接进行逻辑处理 创建Listen，监听TCP端口 gRPC Server 开始 lis.Accept 直到Stop 2.1 编写代码我们先从server那边 grpc.pb.go 文件里面留意两个东西，然后我们需要重新实现的 然后我们在main里面开启端口进行监听 3. 客户端编写 创建与给定目标（服务端)的连接交互 创建server的客户端对象 发送PRC请求，等待同步响应，得到回调后返回响应结果 输出响应结果 3.1 编写代码 可以看到我们服务端运行一次 客户端调用一次 4. 安全传输[SSL&#x2F;TLS]gPRC是一个典型的C&#x2F;S 模型，需要开发客户端和服务端，客户端与服务端需要达成协议，使用某一个确认的传输协议来传输数据，gRPC通常默认是使用protobuf来作为传输协议，当然也是可以使用其它自定义的协议的。 gRPC认证: 不是用户身份认证，而是指多个Server和多个client之间，如何识别对方是谁，并且可以安全的进行数据传入。下面是几种方案。 SSL&#x2F;TLS 认证方式(采用http2协议) 基于Token的认证方式（基于安全链接) 不采用任何措施的链接，这是不安全的链接(默认采用http1) 自定义的身份认证 客户端和服务端之间调用，我们可以通过加入证书的方式，实现调用的安全性. TLS（Transport Layer Security 安全传输层）， TLS 是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL(Secure Socket Layer, 安全套接字层)，它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。 TLS协议主要解决如下三个网络安全问题: 保密(message privacy), 保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探; 完整性(message integrity), 通过MAC校验机制，一旦被篡改，通信双方会立刻发现; 认证(mutual authentication)，双方认证，双方都可以配备证书，防止身份被冒充; 生产环境可以购买证书或者一些平台发放的免费证书 key: 服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密 csr: 证书签名请求文件，用于提交给证书颁发机构(CA) 对证书签名 crt: 由帧数颁发机构(CA) 签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息。 pem: 基于Base64编码的证书格式，扩展名包括PEM、CRT、CER。 我们可以参考这里查看更多: 聊聊HTTPS和SSL&#x2F;TLS协议 4.1 SSL&#x2F;TLS认证方式我们需要通过openssl 生成证书和私钥 下载工具 如果有C语言工具可以通过官网下载下来自己编译(比较复杂): 官网链接 也可以通过别人编译好的工具包来用: 便捷工具 推荐便捷工具，一直下一步（我安装在了我自己喜欢放的目录） 需要把安装好的目录里面/bin配置到环境变量 装好了后新打开一个终端输入 openssl 测试一下，没有报错就是ok了 4.2 生成证书 这里生成的东西是给后面我们生成另外一套东西用的，这里的不引入代码 下面内容不用死记硬背，没意义，每次copy即可 我们在项目中创建一个额外的目录key, 然后在这个目录下执行上面的操作 我们执行完了上面的1 后, key 目录下面会多一个 server.key 文件。 我们执行完了上面的2 后, key 目录下面会多一个 server.crt 文件。 我们执行完了上面的3 后, key 目录下面会多一个 server.csr 文件。 4.3 修改配置 4.4 生成证书私钥 这里生成的东西才是我们代码里面用的 我们经过上面1.2.3 操作后生成了一堆文件 4.5 代码修改 server 端: 只需要增加两行代码 服务端: 这里也是我们只需要修改两行 5. 安全传输[Token]这里十分简单，gRPC给我们提供了一个接口，这个接口有两个方法，接口位于 credentials 包里面，这个接口需要由客户端来实现 上面接口里面两个方法分别作用是: 第一个方法–获取元数据信息，也就是客户端提供的key,value对， context用于控制超时和取消，uri是请求入口处的uri 第二个方法–是否需要基于TLS认证进行安全传输，如果返回值是true,则必须加上TLS验证，返回值是false则不用。【结合操作的话这里改成true其他的和TLS那里设置流程一样的】 5.1 客户端代码 5.2 服务端代码因为我们用的是token校验，所以我们这里校验都在方法里校验 总结可以研究一下 go-zero ，上面的操作可以很轻松的帮我们实现上面的操作。有兴趣可以自己研究一下。"},{"title":"【pandas】结合xlsxwriter变得轻松一点","date":"2023-02-15T09:30:25.000Z","url":"/2023/02/15/pandasSetstyle/","tags":[["python","/tags/python/"],["pandas","/tags/pandas/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"我这个地方是不讲数据处理的，只管内容的样式设置。核心使用pandas 辅助引擎采用 xlsxwriter，不会讲的很细，只会讲几个常用操作。 关于xlsxwriter的更多操作可以点击 这里官方链接 一、基础操作1. 无格式设置按照常规数据来说，基本没有什么格式需求，所以我们可以直接采取最基础的操作：如下 2. 取消超链接但是这样子应付基本的数据没有问题，如果内容是链接，问题就有了 可以看到内容都是超链接格式，内容少问题不大，但是内容多了，那么一个xlsx文件就会巨大，而且生成也慢，而且又不好看。这时候我们就需要引入我们今天的主角了 ： xlsxwriter 这个是一个包来的，可以独立使用，也可以引入pandas引擎作为pandas的插件。 首先得保证我们有这个包 然后我们导出内容的时候就不要直接df.to_excel了 2.1引擎参数上面我们看到我在后面 engine_kwargs=&#123;&quot;options&quot;: &#123;&#125;&#125; 设置了东西，那么这东西我们怎么能知道设置哪些呢？ 我们可以跟进 xlsxwriter 的源码里面，我们进去就可以看到有个class Workbook(xmlwriter.XMLwriter): 的类，下面有个 options = &#123;&#125; 的操作，然后我们开启查找进行标记，可以看到有一堆参数我们进行修改的。 我们刚才使用的 strings_to_urls 就是这里的一个参数，所以同理其他的也能这样子设置。 二、样式操作这里才是我这里今天要讲的核心部分。 这里主要的样式操作啥的，其实还是有很多样式没有写到，我这里就不多写，额只弄常见的一些操作。 下面有两种表格样式 一是基础样式: add_format 还有一个插入表图: add_chart。这两个都是会返回一个样式对象。 然后我们通过 write_row/write (这个我们这里不常用，因为数据我们弄得一般是有了的) merge_range (这里是表格合并的时候可以添加的操作) set_column (设置列的时候添加样式) set_row (设置行的时候添加样式) conditional_format (根据条件添加样式) 等等操作的时候添加那个样式对象的。 我们先逐步假设场景，然后来解决。 1. add_format用于在工作表中创建一个新的格式对象来格式化单元格。 这个是可以单独添加样式的主要操作方式,大概可以设置的参数如下: 如果出现 是否 两个字，表明设置值为 True/False align : 水平对齐方式 left/center/right 不常用的:fill/justify/centre_across/distributed/justify_distributed valign: 垂直对齐方式 top/vcenter/bottom 不常用的:vjustify/vdistributed border: 边框 0无边框 1外边框 ... bold: 是否字体加粗 italic: 是否字体倾斜 font_name: 字体 font_size: 字体大小 font_color: 字体颜色(这里用 #000000 这种格式的最好) text_wrap: 是否自动换行 我们平时操作数据的时候，基本都是利用pandas 然后创建 df = pd.DataFrame ，pandas处理数据能力是非常牛逼，无其它包能敌的。但是美化这一点来说，可以说，基本没有美化。网上之前查询过很多设置pandas样式的操作，就改各种css 结果都不咋地，反正pands自带的一些美化是有，但不多。但是，我们可以利用openpyxl 或者 xlsxwriter 之类的对美化操作很方便的包来实现。但是两边的数据操作的类是不一样的，所以需要进行转化： 我们这里不讲openpyxl,这个工具也很强，但是我还是喜欢用xlsxwriter这里面。 最基础的demo如下： 可以看到我们的内容，表格内的换行是没有了，那么我们这里就需要先利用xlsxwriter来对pandas的df 数据进行美化。 1.1 获取workbook和worksheet 声明: 下面是缩写描述 workbook : 是 xlsxwriter的文件对象 worksheet : 是利用workbook 来获取sheet的对象 在pandas里面我们利用了xlsxwriter引擎后，可以通过创建出来的writer对象获取到我们想要的 1.2 内容换行这里是接着上面内容写的，后面的展示内容均会这样子操作，因为我们设置样式是需要这两个对象的，然后我们只需要对这两个对象操作就好了。 这里是设置了行的属性，如果要设置列，更加简单 后面设置样式的时候，我均只写 workbook 和 worksheet 后面的内容！因为这里的api和普通的xlsx 包无差异。 我们设置了样式之后看看结果： 我们上面设置了 1, 2, 3 行的内容样式 这个数据其实是对应了 我们注释了的 索引(index=False 这个设置隐藏了)的 1,2,3 。这里标题那一栏是0 我们没有设置而已。 可以看到内容已经设置了自动换行，然后我们还设置了一些对齐样式， 其实主要就是讲解这个add_format的一些附加属性操作。 1.3 单元格合并这里我们就不讲获取相同内容值的操作了，我们主要讲一下参数。我们就按照上面那个表，我们想合并周一一样的内容和周二一样的内容，我这里举例子我就不把周一周二一起合并了，周一合并一块，周二合并一块 主要是这个merge_range 有五个参数，其中第五个位置样式可以不写。 2. add_chart在这里我们先准备一些测试用的数据。 和上面一样 我后面操作均不缩进，均单独书写。 2.1 表格样式 type可选参数 描述 area 面积样式图表 bar 条形样式图表 column 柱形样式图表 line 线性样式图表 pie 饼状样式图表 scatter 散点样式图表 stock 股票样式图表 radar 雷达样式图表 我们用柱形样式图表做一个demo~ 3.下拉选择框这里是通过 worksheet.data_validation 来实现的一些下拉框的选择操作。 从上面可以看到其实操作很简单 就只是一个方法而已。 结语暂时写这么一点点，其他的可以去查看最开始的链接。点击这里回到顶部"},{"title":"【反射】go-reflect基本理解","date":"2023-02-14T06:46:58.000Z","url":"/2023/02/14/goReflect/","tags":[["go","/tags/go/"]],"categories":[["摘要","/categories/%E6%91%98%E8%A6%81/"]],"content":"这个东西一般是搞框架或者通用工具包的时候可能会用的多，一般开发基本很少用到，只做了解~如果初学不用着重学习这里 变量的内在机制首先我们了解一下空接口为啥可以接收任意类型的变量。 Go语言中的变量是分为两部分： 类型信息：预先定义好的元信息 值信息：程序运行过程中可动态变化的信息。 反射一、介绍反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。（意思就是：变量名什么的是给我们人看的，方便我们编程使用。程序编译后，这些信息就没有了，都变成内存地址了。） 支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。 二、reflectGo程序在运行期间使用内置的reflect包访问程序的反射信息。Go语言的反射机制中，任何接口值都是由一个具体类型 和具体类型的值 两部分组成(任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成)。并且，reflect 包提供了这两个函数来获取任意对象的Value 和 Type。 1. TypeOf在Go语言中，使用reflect.TypeOf() 函数可以活得任意值的类型对象(reflect.Type),程序通过类型对象可以访问任意值的数据类型信息。 type name 和 type kind 在反射中关于类型还划分为两种: 类型(Type) 和 种类(Kind) 。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类(Kind) 就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类(Kind) 。举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看他们的类型和种类。 可见： 稍微测试一下，Go语言的反射中像数组、切片、Map、指针等类型的变量，他们的.Name() 返回都是空 下图是在reflect 包里面定义的一些Kind 类型。 2. ValueOfreflect.ValueOf() 返回的是reflect.Value 类型，其中包含了原始值的值信息。reflect.Value 与原始值之间可以相互转换。 reflect.Value 类型提供的获取原始值的方法如下: 方法 说明 Interface() interface {} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型 Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回 Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 Bool() bool 将值以 bool 类型返回 Bytes() []bytes 将值以字节数组 []bytes 类型返回 String() string 将值以字符串类型返回 通过反射获取值 通过反射设置变量的值想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。 3. isNil() 和 isValid() IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。 isNil()IsNil()返回v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。 isValid()IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。 使用示例 4. 结构体反射与结构体相关的方法任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。 reflect.Type中与获取结构体成员相关的的方法如下表所示。 方法 说明 Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。 NumField() int 返回结构体成员字段数量。 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。 NumMethod() int 返回该类型的方法集中方法的数目 Method(int) Method 返回该类型方法集中的第i个方法 MethodByName(string)(Method, bool) 根据方法名返回该类型方法集中的方法 StructField类型StructField类型用来描述结构体中的一个字段的信息。定义如下： 结构体反射示例当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。 三、总结这东西一般开发的时候很少用到，可能在需要写一些框架，通用工具的时候才会用到，增加兼容性~ 反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。 基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。 大量使用反射的代码通常难以理解。 反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。 本文参考李文周的博客 [-] Go语言基础之反射 "},{"title":"【goSwagger】goswagger+gin配置踩坑","date":"2023-02-10T03:14:15.000Z","url":"/2023/02/10/goSwagger/","tags":[["go","/tags/go/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"搭建一个swagger页面 手把手教学 一、基本介绍1. 页面展示 最终页面 我们将用上面的几个例子来展示一下几种普通请求的使用方式，然后再稍微 讲一下常用的一些参数，其它参数我代码里面不会展示，但是可以尝试配置一下，逻辑一样的。 代码层级 二、实战1. 开始官方文档地址 快速查询中文文档 : github的，可以查查 1.1 安装goswagger 如果上面安装了但是swag.exe 不在 GOPATH/bin 里面那么就需要执行下面操作 安装完了之后，如果swag 这个命令还不可以使用，这时候我们需要去到GOPATH/pkg/mod/github.com/swaggo/swag@版本号 这个位置执行一下go install 然后我们重启一下cmd 尝试一下是否可以返回版本号 然后我们继续安装其它包 1.2 目录介绍这里项目名称我是随意写的，我这里是webbase 然后这个东西在GOPATH/src/LearnTest 下面，所以后面很多包的引用目录位置是从LearnTest/webbase/xxxxx 这样子的 1) main.go这里只负责启动路由，下面我写了很多注释在文件开头，这里我会和图片一起对照讲解。 注解 描述 title 必需的。应用程序的标题。 version 必需的。提供应用程序API的版本 description 应用程序的简短描述。 termsOfService API的服务条款。 contact.name 公开的API的联系信息。 contact.url 指向联系信息的URL。必须采用网址格式。 contact.email 联系人&#x2F;组织的电子邮件地址。必须采用电子邮件地址的格式。 license.name 必需的。用于API的许可证名称。 license.url 用于该API的许可证的URL。必须采用网址格式。 host 提供API的主机（名称或IP）。 BasePath 提供API的基本路径。 这里有些东西不是必须写的 我这里写了四个板块(用换行符分割的)。这里面只要呈现了超链接样子的东西都可以不写的。核心是最后那个host 如果你是放在有nginx 服务的地方的话这里写127.0.0.1:xxxx 完全没有问题，那么你将碰不到任何错误 如果是单机测试，你写127.0.0.1:xxxx 也没有任何问题，访问也不会出错 如果你写了127.0.0.1:xxxx 然后要给内网小伙伴玩，那么你会遇到如下问题，他用内网IP访问你的服务，swagger页面可以打开，但是api服务访问会出现CORS问题。 如果你写了内网ip:xxxx 然后给内网小伙伴玩，那么一般是不会遇到任何问题的。但是，此时你自己用127.0.0.1:xxxx 去访问，你自己又会碰到CORS错误。这时候我们可以利用添加一个CORS 中间件来处理这个问题，下一个板块我就会写到，因为里面没啥东西讲的，先写前面。 添加中间件后，我们测试访问GET 请求没问题，POST json数据依旧会出现CORS 问题，我们打开浏览器抓包一下请求看看 这时候我们就只好也走内网ip 然后接下来都ok 所以推荐host 参数设置如下 这个位置如果是nginx服务，就写127.0.0.1即可。 如果是内网，那么大家都用内网ip访问。 如果是公网，那么就公网访问，也不会有问题。 2) middlewares&#x2F;cors.go这里是我同源策略处理问题的时候，这里可以解决部分问题。毕竟这个地方可以在nginx 那里面替代处理 这个使用的地方是在router.go里面 3) router&#x2F;router.go 4) controller&#x2F;controller.go这里先展示最上面每个函数都可能会用到的东西 下面代码都是接着上面写的 我们先对每一个板块单独写下来，然后汇总说一下 GET-query GET-param POST-json POST-data 通用模块位置， 下面出现的 MIME 参数类型 数据类型 param参数类型 都在[二–&gt; 1.3]里面详解 下面的很多参数用不到可以不写，可以看到我上面也不是全部都写的，对大小写不敏感 单独说的参数 Router : 这个其它参数都没有啥问题，就是取值类型为param的时候，这里我们不能按照gin url里面xxx/:a/:b 这样子写，这里我们需要写成xxx/&#123;a&#125;/&#123;b&#125; Param : 这个地方只有几个地方需要变就是param参数类型，统一的格式就是 // @Param 参数名称 param参数类型 数据类型 是否必须 备注 限制属性 这里的详细讲解见 1.3 下面的 param参数类型 和限制属性. Success / Failure : 这里 格式是空格分隔 我们需要写如下几个参数，只会展示成功失败返回数据的基本模板，不会有具体值，这里也不会影响程序结果，只是模板， 所以可以定义多个成功和失败展示不同状态码的成功和失败的返回值 Security : 这个可以不写，写了就是做一些api校验，用的很少，如果要用可以查文档 通用API信息 每个API操作 使用AND条件 这里摘抄自 中文文档:  1.3 类型参数MIME 参数 参数类型 json application&#x2F;json x-www-form-urlencoded application&#x2F;x-www-form-urlencoded xml text&#x2F;xml plain text&#x2F;plain html text&#x2F;html mpfd multipart&#x2F;form-data json-api application&#x2F;vnd.api+json json-stream application&#x2F;x-json-stream octet-stream application&#x2F;octet-stream png image&#x2F;png jpeg image&#x2F;jpeg gif image&#x2F;gif 参数类型 参数类型 Param Type object (struct 类型的东西写这个) string (string 类型写这个) integer (int, uinit, uint32, uint64 都写这个) number (float32 类型写这个称呼) boolean (bool) array 数据类型 数据类型Data Type string (string) integer (int, uint, uint32, uint64) number (float32) boolean (bool) user defined struct &#x2F;&#x2F; 这里就比如我上面定义的成功失败的结构体 param参数类型 query : 这个类型是取 url? 后面的数据的值，有几个参数就写几行 如下示例 path : 这个类型是取restful格式的url的值 如路由那边写 url/user/:name/:age ,不过这里的Router得写成 url/user/&#123;name&#125;/&#123;age&#125; 下面才可以正常取值 header : 这个是需要附加header里面参数的,这里注意不能是中文，最好是英文数字英文符号 body : 这个是设置Json的数据,这里不和其它参数一样，这里最好只设置一个，设置多了虽然页面也会展示，但是api访问只会取最后一个框，他这个位置的第一个位置参数名无实际作用，配套的得在前面加一行传入参数限制才好。如下，name 无实际作用 formDate : 取form-data的值的，有几个写几行 限制属性 这里可以多个一起往后面写 也可以不写表示不限制，下面【】里面的是示例 没有示例的不咋常用 defualt * 参数默认值 【default(666) default(这就是默认值)】 maximum number 最大值 【maximum(199.99)】 mininum number 最小值 【mininum(6.66)】 maxLength integer 最大长度 【maxLength(1000)】 minLength integer 最小长度 【minLength(1)】 enums [*] 枚举类型 【enums(0, 1)】 format string collectionFormat string query 数组分割模式 1.4 注意事项 多字段定义时候不能跨字段，如两个相同的类型定义 修改定义后需要重新执行，生成命令并重启服务 路由配置的时候，需要引入文档 备注那些字 一定有双引号包裹，不能裸奔 2. 运行 访问页面测试，没有问题就行。 API单独访问是肯定没有问题的，主要是在swagger页面可能会出现一些问题。"},{"title":"【泛型】go语言泛型编程","date":"2023-02-07T08:02:44.000Z","url":"/2023/02/07/goGenericbase/","tags":[["go","/tags/go/"]],"categories":[["摘要","/categories/%E6%91%98%E8%A6%81/"]],"content":"go 1.18 后面才有的内容 更详细的推荐下面这篇文章: Go 1.18 泛型全面讲解：一篇讲清泛型的全部 按照往常我们用interface 实现不同类型的参数接收，但是我们需要对它类型断言判断，如果有多种不同类型参数，那么我们就要多个if 判断，如下： 现在我们多了泛型,可以大大的简化这个过程 内置的泛型 any 和 comparable any: 表示go里面所有的内置基本类型，等价于interface&#123;&#125; comparable: 表示go里面所有内置的可比较类型–&gt; int,uint,float,bool,struct,指针等一切可以比较的类型 总结：泛型的作用 泛型减少重复代码并提高类型的安全性 泛型最佳适配场合 需要针对不同类型书写同样的逻辑 使用泛型简化代码 "},{"title":"【Go web】后台框架入门","date":"2023-02-07T01:07:26.000Z","url":"/2023/02/07/go-webbase/","tags":[["go","/tags/go/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":" 逐步更新，但是这里只是入门板块，进阶板块后面会单独章节写。 计划逐步记录的框架 –&gt; Gin、Beego、Iris 一、框架选择我们简单了解一下部分后端框架，不是全部，还有很多其他的，目前我们大概了解一下如下框架 Gin : Go语言编写的Web框架，以更好的性能实现类似Martini 框架的API Gin是一个Golang 的微框架，封装比较优雅，API友好，源码注释比较明确。具有快速灵活，容错方便等特点。 Beego : 开源的高性能Go语言Web框架 beego 是一个快速开发Go应用的http 框架，go 语言方面技术大牛。beego 可以用来快速开发API、Web、后端 服务等各种应用，是一个RESTFul 的框架，主要设计灵感来源于tornado 、sinatra 、flask 这三个框架，但是结合了Go本身的-一些特性(interface、struct 继承等)而设计的一个框架。 Iris : 全宇宙最快的Go语言Web框架，完备的MVC 支持，未来尽在掌握 Iris是一个快速，简单但功能齐全的和非常有效的web框架，提供了一个优美的表现力和容易使用你的下一个网站或者API 的基础 二、开始Gin1. 安装 可能出现网络异常，修复手段如下 1.0 异常如果没有出现网络异常就可以忽略这里的板块，直接看后面的操作步骤 2. hello1) restful基本模板目前的目录结构 我们先创建一个最基本的模板 0) pycharm 异常如果出现以下问题，可以查看一下是否下面两种情况异常，如果没有出现这种异常可以忽略下面操作 首先我们需要在settings 里面找到GOPATH 把Index entire GOPATH 这个选择勾上 然后在Go Modules 把我们配置的GOPROXY 如图配置上即可 2) 渲染前端目前的目录结构 我们创建一个前端模板 前端需要一个msg参数 所以我们后端需要传递过来渲染 其中上面前端页面的资源引入这样子写了是不可以直接引用的，还需要go服务那边加载静态文件 测试响应状态 3. 获取参数下面是几种基础请求方案 从传来的参数获取值 当然判断逻辑那些是在获取参数和返回结果之间处理 这里逻辑就不概述了 4. 路由操作1) 重定向 2) 路由组这里可以将同类型功能单独封装 5. 中间件对数据预处理，授权验证，统计啥的… Beego未完待续…… Iris未完待续……"},{"title":"【Docker】万字详细笔记","date":"2023-01-19T10:30:03.000Z","url":"/2023/01/19/dockernotes/","tags":[["docker","/tags/docker/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"基本的概念部分就不细说了，容器~ 我们直接从部署到使用学习开始好了。 后面内容部分说明：如果命令前面有 [root@heartfilia ~]# 这样子，或者截图里面打了马赛克的部分，这里的命令表示是在宿主主机执行的命令 否则为在容器内执行的命令~ 一、基础1. docker和虚拟机区别 传统的虚拟机方案 虚拟机技术缺点: 资源暂用比较多 冗余步骤多 启动慢 容器化技术 容器化技术不是模拟的一个完整的操作系统 比较docker和虚拟机技术的不同： 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内核，容器是没有自己的内核，也没有虚拟硬件，所以很轻快 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响 DevOps(开发、运维) docker可以更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker: 打包镜像发布测试，一键运行，更便捷的升级和扩容缩，更简单的系统运维，更高效的计算资源利用(内核级别的虚拟化， 可以在一个物理机上可以运行很多的容器实例，服务器的性能可以被压榨到极致) docker的架构图： 镜像(image)： docker的镜像好比是一个模板，可以通过这个模板来创建容器服务，通过这个镜像可以创建多个容器，最终的服务或项目运行实在容器中运行 容器(container)： docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。 启动，停止，删除，这些基本命令运行即可！ 目前就可以把这个容器理解为一个简易的linux系统 仓库(repository)： 仓库就是存放镜像的地方 仓库分为公有仓库和私有仓库 Docker Hub(默认官方 国外的) 阿里云…等等都有第三方镜像服务 2. docker的安装2.1 环境准备我们目前用linux 学习， 在/ 目录下进行接下来的操作 2.2 安装 官方的帮助文档很详细，下面的内容均为复制帮助文档里面的 1) 卸载旧版本 2) 通过仓库安装 3) 默认安装docker下面是默认安装最新版 如果这里报错：Failed to download metadata for repo…那么需要改一些东西才可以使用 报错原因: 识别版本异常 我们打开/etc/yum.repos.d/docker-ce.repo 会发现 /$releasever/ 有这个东西，这东西是要你去匹配系统版本的，我这里异常示例 所以我们手动修改那个数据为对应版本的系统版本，如你的centos版本号 4) 如果需要安装其它docker版本（执行了3就不用执行这里了） 选择你需要安装的版本(: 后面的是版本号) 如我这里选择 18.09.0 docker-ce 社区版 ee 企业版 5) 启动docker 可以测试一下看看docker详情 其它特殊服务器情况(主流过的国外系统都在官网有教程，我这里是官网没有的教程的服务器) 我这里服务器是华为的欧拉服务器 需要更改一下源 然后再安装 6) 测试是否成功 然后可以通过，以下命令查看运行情况 7) 卸载docker具体参照 官方教程最下面移除板块，我这里是centos 的移除 2.3 镜像加速这里就是可以绑定某个服务商的镜像加速哒，大体都是去 阿里云，腾讯云，百度云，华为云…这些等等这些后台创建了后搜索一下找到配置文件一键配置就好了 搜索 容器镜像服务 2.4 底层原理1) docker run 原理 2) docker工作原理Docker 是一个client-server 结果的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问 DockerServer 接收到的Docker-Client指令，就会执行这个命令~ 下图可以看到 docker容器是和linux服务器是独立的 连通后面再讲 Docker 为什么比虚拟机快 Docker有着比虚拟机更少的抽象层 Docker 利用的是宿主机的内核，vm需要GuestOS 所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导，虚拟机是需要加载guestos，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程是秒级的~ 二、开始1. Docker 常用命令 这里的命令目前是最基础部分，后面会持续拓展，docker命令十分多，先记录常用的 1.1 帮助命令 帮助文档地址点这里 DockerHub点这里 1.2 镜像命令下面的可选项只列举了常用的，其它的还有的可以通过 docker help xxx 或者 docker xxx --help 来进行查看更多操作或者去帮助文档 1) docker images 查看所有本地的主机上的镜像 2) docker search 搜索镜像 3) docker pull 下载镜像 4) docker rmi 删除镜像 1.3 容器命令 说明：有镜像才可以创建容器，下载一个centos镜像来测试学习 1) docker run 新建容器并启动 2) docker ps 查看当前运行的容器 3) 退出容器 4) docker rm 删除容器 5) 容器状态管理 1.4 主要常用命令1) 后台启动 2) 查看日志 3) 查看进程 4) docker inspect 【重要】 查看容器的信息，元数据 5) docker exec 【重要】 进入容器并执行操作 6) docker attach 进入容器正在运行的状态 5和6两点的区别 docker exec 进入容器后开启一个新的终端，可以在里面操作 docker attach 进入容器正在执行的终端，不会启动新的进程(容器是否在运行没有关系) 7) docker cp 从容器内拷贝文件到主机上 目前拷贝是一个手动过程，后续我们可以使用 -v 卷的技术，可以实现，自动同步 文件操作流程图 8) docker stats 查看docker的运行状态 9) docker commit 这里在 二 --&gt; 4 --&gt; 4.3 板块细说 2. Docker练习2.1 安装nginx 端口暴露原理如图 2.2 安装tomcat 2.3 部署ES + Kibana1) 安装ES 2) 安装Kibana 思考一下是否可以在本机部署服务然后利用容器内的nginx来控制呢? (-v 卷技术在后面等我们呢) 以后部署项目，每次都要进入容器是不是十分麻烦？(要是可以在容器外部提供一个映射路径，我们在外部修改项目，自动同步到内部就好~同理还是 -v 卷技术) 3. 可视化3.1 portainer (临时) 不是最好的选择，但是目前我们先用这个 1) 开始 2) 额外说的一般不会使用可视化面板，测试玩一玩就可以了 3.2 Rancher (CI&#x2F;CD 时候使用) 先放着 4. docker镜像4.1 镜像是什么docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）；镜像不包含任何动态数据，其内容在构建之后也不会被改变。 所有的应用，直接打包docker镜像，可以直接跑起来~ 如何得到镜像: 远程仓库下载 朋友拷贝 自己制作一个镜像DockerFile 4.2 Docker镜像加载原理 UnionFS (联合文件系统) 我们下载镜像的时候看到一层一层的下载就是这东西~ UnionFs: UnionFS 时一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。 加载原理 Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS（联合文件系统）。 bootfs（boot file system）：主要包含bootloader和kernel（Linux内核），bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，而在Docker镜像的最底层也是bootfs这一层，这与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后，整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。【系统启动需要引导加载】 即：系统启动时需要的引导加载，这个过程会需要一定时间。就是黑屏到开机之间的这么一个过程。电脑、虚拟机、Docker容器启动都需要的过程。在说回镜像，所以这一部分，无论是什么镜像都是公用的。 rootfs（root file system）：rootfs在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 即：镜像启动之后的一个小的底层系统，这就是我们之前所说的，容器就是一个小的虚拟机环境，比如Ubuntu，Centos等，这个小的虚拟机环境就相当于rootfs。 根据架构图来深度理解一下 所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。 举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。 该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。 在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而整体的镜像包含了来自两个镜像层的6个文件 上图中的鏡像层跟之前图中的略有区别，主要目的是便于展示文件。 下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。 特点 docker 的镜像是只读的，容器启动时，一个新的可写层被加载到镜像的顶部，这一层就是容器层，容器之下的都叫镜像层 4.3 提交镜像 docker commit 到这里，docker才算入门~ 三、进阶【重点】1. 容器数据卷1.1 概念如果数据在容器中，容器删除，数据就会丢失~ 需求: 数据可以持久化 MySQL的容器，容器删了，删库跑路？ 需求: MySql数据可以存储在本地 所以：卷技术就是容器之间数据共享的技术，Docker容器中产生的数据，同步到本地 这就是卷技术，目录的挂载，将我们容器内的目录，挂载到linux上面~ 总结：容器的持久化和同步操作，容器间也可以数据共享。 1.2 使用数据卷 方式一: 直接使用命令来挂载 -v 我们关注一下 docker的信息 弄好了后，在容器里面或者主机上面添加删除内容，两边都是同步的~ 哪怕容器关闭了，我们在主机上操作文件后，容器打开也是可以同步看到，因为是映射关系~ 好处：我们以后修改只需要在本地修改即可，容器内会自动同步 方式二: docker volumes 后面具名，匿名挂载部分讲解 1.3 实战练习Mysql安装配置 拉取mysql镜像 通过绑定配置文件启动 1.4 挂载模式 具名和匿名挂载，后面跟了中文的是用的多的，其他的可以点击进官网查看 docker volume docker volume create docker volume inspect :后跟卷名可以查看详细信息 docker volume ls :查看所有卷情况 docker volume prune docker volume rm 1) 匿名挂载 2) 具名挂载 所有docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxxxxxxx/_data 这个目录下 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下试用 具名挂载 3) 拓展 通过-v 容器内路径:ro&#x2F;rw 改变读写权限 1.5 初识DockerFile 构建docker镜像的构造文件 关键词命令都是大写的 我们可以通过 docker inspect 容器id 查看一下 Mounts 挂载的两个目录，测试一下在容器内修改内容 容器外的目录内容情况 未来使用这种方式非常多，因为我们会经常构建自己的镜像 如果构建容器的时候没有挂载卷，我们仍然可以采用 -v 卷名:容器内路径来手动挂载 1.6 数据卷容器多个容器内进行沟通，数据同步 多个mysql数据共享 结论： 容器之间配置信息的传递，数据卷容器的声明周期一直持续到没有容器使用为止。但是一旦持久化到了本地，这个时候，本地数据不会删除 2. DockerFile2.1 构建步骤 编写dockerfile文件 docker build 构建成一个镜像 docker run 运行镜像 docker push 发布镜像 (DockerHub、私有云仓库) 官方放到github的 所以我们也可以按照这样子 很多官方镜像都是基础包，很多功能是没有的，我们通常会自己搭建自己的镜像 2.2 构建过程1) 基础知识 每个保留关键字(指令) 建议都是大写字母 指令从上到下顺序执行 # 表示注释 每一条指令都会创建一个新的镜像层，并提交。 4) 完整流程DockerFile : 构建文件，定义了一切步骤 DockerImages : 通过DockerFile构建生成的镜像，最终发布和运行的产品 DockerContainer : 容器就是镜像运行起来提供的服务器 2.3 指令 1) 构建centos测试 Docker Hub 中99%镜像都是从 scratch 开始的 编写文件 构建镜像 2) docker history 可以查看镜像的构建过程 我们平时拿到一个镜像可以用上面指令研究一下别人怎么做的 3) CMD 和 ENTRYPOINT 区别 CMD ENTRYPOINT Dockerfile中很多命令都十分相似，我们需要了解他们的区别，最好的学习方法就是对比然后测试结果 4) 构建tomcat测试 准备镜像文件 tomcat 压缩包，jdk压缩包（我这里网络不好就没有下载 直接用截图了） 编写dockerfile文件，官方命名 Dockerfile ,如果用这个 build的时候就会自动去用这个文件 就不用 -f dockerfile名字了 构建镜像 写完了后，因为我们用的官方的标准名称 所以可以如下操作 运行容器 访问测试 发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了) 需要注册自己的账号 （dockerhub 板块） 确定可以登录 在服务器上提交自己的镜像 docker login docker tag : 给镜像打标签和重命名 发布到自己的镜像服务的话 我这里直接截图别人的操作了 剩下的直接按照教程就好了~ 0. 总结 3. Docker网络3.1 理解Docker0 建议清空所有镜像和容器 来学习理解 原理 我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair 技术 在主机再次用 ip addr 测试会发现会多一个网络出来 再启动一个容器，发现又多了一对网卡。 evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段链接着协议，一段彼此相连 正因为有这个特性，veth-pair 充当一个桥梁，链接着各种虚拟网络设备 OpenStac, Docker 容器之间的链接， OVS的链接，都是使用的 veth-pair 技术 我们测试容器间是否能相互ping(容器内可能没有这个命令还是得去单独下载apt install -y iputils-ping) ：可以ping通！ 结论 :所有的容器不指定网络的情况下，都是docker0 路由的，docker会给我们的容器分配一个默认的可用IP 3.2 小结Docker 使用的linux的 桥接， 宿主机中的一个Docker容器的网桥 docker0 Docker 中的所有的网络接口都是虚拟的，虚拟的转发效率高 (内网传递效率快) 只要容器删除，对应的网桥一对就没有了。 3.3 –link就是一个hosts映射, 真实使用的时候不建议用这个了操作了，但是原理我们要了解~ 思考: 编写一个微服务，项目不重启，数据ip更换，可以通过名字来访问容器？ docker network : 可以查看以下操作 3.4 自定义网络 查看所有的docker网络 我们创建好了一个我们自己的网络 后面就可以都用我们自己的网络来操作 自己创建的网络是全部都支持的 好处 我们可以redis创建一个网络，mysql创建一个网络，这样子不同集群使用不同网络，保证集群是安全和健康的 3.5 网络连通在不同的网络的容器可以连通,如a容器在自定义网络1 b容器在自定义网络2 这样子的，a容器需要和b容器通信就需要这样子操作 docker network connect tomcat01 能和 mynet通信原理 相当于直接把tomcat01 放到了这个网络里面来实现的 4. 实战4.1 redis集群部署 然后通过脚本创建六个redis配置 然后通过命令启动六个redis 如果看到启动后 容器直接失效 可以通过以下命令查看一下情况 我们进入任意一个redis一下，注意很多版本的redis是没有bash的 所以我们要用sh进入 下面是我们随便进入的一个 然后我们配置一下集群 链接集群 现在我们先随便存一个数据值试试 然后我们新开一个窗口把二号redis给停了 如果有更多镜像需要管理就需要下面的板块来搞了~ 四、企业实战1. Docker Compose… 2. Docker Swarm大概参考位置 首先需要多台服务器，最好是在同一内网网段的(公网慢而且说不定要钱) 每台都安装了docker 概念 有两种节点：管理节点(操作都在manager) 和 工作节点(执行worker) 一般10台以下可以这么玩，多了就需要k8s了 manager要奇数的(类似投票机制 所以一般要3以上奇数) 搭建集群开始 2.1 命令详解1) docker swarm 创建一个集群 然后我们先创建一个manager 主节点 docker swarm init 初始化节点 docker swarm join 加入一个节点 我们查看以下1号服务器节点状态 3. CI&#x2F;CD Jenkins 流水线… 0. k8s容器单独没有什么意义，有意义的是这里需要学习的k8s 这个地方后面单独一个版块学习，这个docker部分将不会讲到~ 但是学这里需要掌握的东西先准备好： Go语言 必须掌握 一些并发语言 "},{"title":"【数据转换】python实现其它代码中轻易实现的逻辑","date":"2022-12-14T02:19:22.000Z","url":"/2022/12/14/codetrans/","tags":[["python","/tags/python/"]],"categories":[["代码","/categories/%E4%BB%A3%E7%A0%81/"]],"content":"一些在其它语言可以轻易实现的功能，但是在python中会有点误差的实现方案 这里的内容会持续更新，新增！ JS板块一. 浮点数转二进制 实现方案一 实现方案二 实现方案三 二、逻辑运算转换在 JavaScript 内部，数值都是以 64 位浮点数的形式储存，但是做位运算的时候，是以 32 位带符号的整数进行运算的，并且返回值也是一个 32 位带符号的整数。目的是使在 python 中的显示和 js 中的显示相同，就在 Python 中做一次从 uint32 到 int32 的转换。 1.逻辑符号 ^ 实现方案一 实现方案二 2.无符号右移 &gt;&gt;&gt;这里目前还没有完美的方案，数据量非常大的时候可能需要加上 板块二 逻辑符号 ^ 里面数据量过大情况进行数据修正，大概意思就是这个得出来的结果再套一层。 示例：采用逻辑符号 ^ 方案二 –&gt; int_overflow(这里就是无符号右移得出来的结果) 实现方案一 实现方案二 实现方案三 实现方案四-小小白提供 "},{"title":"【应用破解】Navicat重置试用","date":"2022-12-08T01:54:22.000Z","url":"/2022/12/08/navicat-reset/","tags":[["注册机","/tags/%E6%B3%A8%E5%86%8C%E6%9C%BA/"]],"categories":[["资源","/categories/%E8%B5%84%E6%BA%90/"]],"content":"懒得破解navicat 或者 避免被 递传票 可以试试以下方案 本地教程只适用于非商业用途，其余看个人 以下代码只适用于windows 就是通过代码的方案，把本地注册表里面记录navicat premium的信息给抹了，然后就可以实现无限重置的效果，这个方法基本适用于所有版本，所以去官网下载 navicat 最新版即可《经校验，16.2.3版本的时候已经不可以用了，所以在16.2.1及以下版本的还是别更新了》! Python代码这里是给有python环境的小可爱们准备的 python代码 没有python环境的小可爱 创建一个空白的txt文件在任意位置都行 在里面粘贴下方代码 bat代码 保存然后关闭窗口 修改文件名称把末尾的.txt 改成 .bat 有的小可爱可能看不到这个.txt ,那么需要在windows文件管理器上面点击查看 -&gt; 显示 -&gt; 文件的扩展名 勾上 然后保存文件，关闭窗口 然后双击这个文件 弹出来一个窗口 显示Finish 即可 总体来说没啥难度，复制粘贴，然后就可以得到一个正版的不会被递传票的工具拉~"},{"title":"【hexo】从零开始搭建一个博客","date":"2022-12-06T04:27:27.000Z","url":"/2022/12/06/hexo/","tags":[["美化","/tags/%E7%BE%8E%E5%8C%96/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"从环境到项目部署成功一个hexo博客的教程~ 我们这里是讲把项目部署到github pages 服务器部署自己搞 很简单的 都一样我这里是在linux服务器上面弄的，如果你是windows本地弄的话 基本都一样 就是弄git密钥的时候有点差别百度一下就好了 一、前期准备1.node1.1 安装这里没啥好说的，直接去官网下载或者直接用服务器的镜像源的，但是建议–&gt;node版本不要太低了,去官网下载就下载最新的长期支持版本就好了，用服务器源的话最好不要低于10版本，我这里懒得去官网弄，我直接用我服务器的yum源里的nodejs，我的node是12+版本的 1.2 注意因为国内源比较慢，我们这里建议更新一下npm的源，后续下载任务操作会快很多，我这里直接用了cnpm的安装源(没有用cnpm只是用了他的镜像哈哈) 配置完后可以查看一下 2.git这里是教如何搭建github pages并和hexo关联安装git就不用这里教了，网上一大把教程 我这里还是直接 yum install git 3. 为啥要写这个来源于hexo官网下面的评论确实很多地方看着迷迷糊糊的，都是自己去多试试，然后想记录下来 二、GithubPages操作1.github设置在主页这里创建一个仓库 建议先别创建README 我们就只要一个空仓库，里面会有很多绑定仓库的提示，不会玩的话搞不好会冲突哈哈哈 2.服务器git配置2.1配置git我们这里需要配置一下git，我们现在在服务器上面先绑定github啦 登录了github后，在Settings里面找到 SSH and GPG keys然后点击New SSH key标题随便取，我是要做页面的我标注一下 github.io 下面的key把上面cat出来的内容复制过来粘贴上去除首位空字符然后我们测试一下ssh -T git@github.com出现了用户名就是ok的，如下 2.2 如何关联到hexo这里我们先不描述 上面操作完了后就先等等，我们接下来看看代码那边如何配置先这里是后面配置完了再翻回来看这里的等hexo项目创建好了后，我们根据创建的仓库页面的提示信息 我们在hexo项目里面初始化git然后把本地的绑定到远程main(老版本可能叫master) 这里就是无脑复制github空白仓库里面的提示信息，以后每次操作前建议先 git pull 一下，然后再改文件测试 然后再进行git三连 git add . # 因为有.gitignore文件 所以我们直接add . git commit -m 提交的信息 git push origin main # 老版本可能叫master 然后我们在github 我们创建的这个仓库上面点击 setttings Pages Branch 这里选择 我们deploy 那里填的那个分支，我这里填写的 pages 后面只要hexo d 等传输完毕后，github这里会构建，我们可以在 github仓库页面上面的 Actions目录下面看到构建的进度如果这里绿了就可以访问啦～是不是很奇怪，这里才是文章的最终结束～ 三、hexo的启动部署1.安装我们打开 hexo官网，因为开发者是一个台湾人，所以中文支持比较好，可以直接中文阅读网站直接输入主页给我们的 1.1 模型预览这里参考可以去这里看看，然后下载自己喜欢的模型就ok了 模型预览我这里用的是 npm install --save live2d-widget-model-shizuku然后在主配置文件下面加上这个就好了， 页面加载这个东西会有点点慢 但是不会太久 装完了后 可以在终端测试一下 hexo version 查看一下是否正常输出内容，如果ok的话我们进行接下来的操作步骤 2.初始化我们找到一个目录里面就专门放以后存放的各种博客网站，不找目录直接在 ~目录下也可以操作hexo init myBlogs这样会初始化一个myBlogs目录出来，这里的名称随意我是自己创建了一个blogs父目录，然后在里面init项目，这样子方便多个项目管理好看上面操作在配置了前期准备里面换源后是会比较快完成然后进入我们刚才init好的项目这里我进入cd myBlogs,然后执行 npm install即可后续页面有改动那些，可以先使用hexo cl清理之前的缓存然后再执行下面的操作然后hexo g 计算一下文件然后hexo server -p 80在80端口开启一个服务最后我们直接浏览器输入ip访问一下，看看是不是会出来如下一个页面测试完没有问题可以直接ctrl + c停止服务如果到这里都可以，那么最基础的搭建已经完成了，接下来就是 美化及 日常更新了 3. 美化3.1 挑选主题我们去这里挑选喜欢的主题**我这里选择的是 **ParticleX 再推荐两个好看的主题 后面我也要换一下  (目前我用的这个这个好看) 3.2 下载主题按照github页面介绍 我们在主题目录下执行命令 然后返回项目主目录 我这里的 /root/blogs/myBlogs下面找到 _config.yml我们进行一些基础的配置，后面还有主题的配置我们单独再说 3.3 项目配置文件&gt; 一些描述信息注意下面是yaml文件，:后面必须要空格, 单引号可写可不写 &gt; 配置 按照github网站介绍，关闭highlight和prismjs 上面两个主配置这里 enable: false只需要把这里设置为false 即可 然后把主题那里换乘我们theme文件夹下面的主题名称 我这里是themesparticlex我就换成这个 每次要重新测试啥的最好都按照如下操作执行一下 hexo cl 清理静态文件缓存 hexo g 重新生成静态文件 hexo s -p 80 开启一个80端口的服务，不加-p 80默认是4000端口 后续配置 deploy &gt; GitHubPage配置 3.4 主题配置文件&gt; 主题下面的这里的配置文件是在theme/xxxx/_config.yml可以看到里面很多图片其实是空的我这里先添加一些图片，这里为了图片长久可以使用，我这里注册了一个七牛云 每个用户有10G的存储空间，我把一些图片视频啥的就往里面放的 &gt; 常用配置 我这里简单的配置了一下 然后返回项目目录下执行**老三样, **然后我们去浏览器看一下，如果之前有浏览过，可能会有浏览器缓存，看不出来新样式，这里建议，测试的时候用 浏览器无痕浏览 4.日常更新接下来我们就来讲讲日常的博客日志更新维护，在这之前先留意一下这里这里我们目前直接去点 很多东西都没有反馈的，那是因为我们没有项目填充，如果不想要这里可以直接在配置文件里面注释掉对应的板块 如果要把上面写的改成自己写的内容的话如图直接如下demo那样子修改就好了 为了能正常显示上面的内容 我们这里需要手动创建几个页面，如果你需要添加其它页面也需要同样的创建一下 创建了上面的页面后，目前来说这里是不需要做任何操作的 这些东西都在 source/这个目录下面 点进去就可以看到对应了上面创建出来的目录，里面有一个 index.md 然后要做啥就在里面操作就好了 4.1 项目创建具体详细的命令啥的去官网查看我们直接在主目录下面执行hexo new 文章标题 &gt;&gt; 这里的标题一般来说中文英文都可以建议这里用 英文 然后标题在markdown文件里面去修改然后我们会在主目录下面的source/_posts下面有一个同名的md文件这里默认会有一个hello-world.md存在，我这里面删除了接下来我们就可以直接编辑这个markdown文件了 我们用hexo new 创建的文件里面会有一些默认的参数在里面这里创建是只创建一个md文件，如果里面有本地图片的话，可以在config.yml 文件中的 post_asset_folder 选项设为 true 来打开，然后再创建就是一个文件夹，然后就可以在文件夹里面引用本地的静态文件了，不建议自己弄，图片多了巨卡巨卡巨卡巨卡巨卡巨卡 &gt; 博客内容标签解释 想看看可以浏览一下我的博客 关于草稿 还有 资源文件 还有啥东西的 可以去 标签插件 资源文件夹 数据文件夹 4.2 项目发布只要弄好了都弄好了我们就 5.留言功能我们可以从我们上面这个主题那里看到其实是有两个默认的留言功能选择给我们 我这里选择了第二个 waline 这东西有个不好的，就是后面要用的一个服务端得有科学才可以正常使用，不过问题不大是吧我们去 waline官网 跟着他们的教程其实也可以直接搭建好，我这里直接用它提供的文档来弄 熟悉按照这里 我们先去注册一个 存储服务 这里使用的是 leancloud 这东西国际版要科学， 国内版需要备案 我们直接点页面上很明显的然后用github绑定登录一下就好了，按照它下面贴的那两个B站教学视频可以完成这里的操作，不懂得反复看一下就好了最后我们拿到属于自己的一个服务地址 然后我们填入主题的配置里面 然后我们在部署好的博客的单篇文章下面就会有一个评论框了 题外话其他主题很多配置不太一样，可以根据主题的作者写出来的教程慢慢来配置就好啦目前我这里还有很多没有美化完，后面继续美化"},{"title":"【表格资源】资源链接分享","date":"2022-12-05T06:46:53.000Z","url":"/2022/12/05/resoure-link/","tags":[["表格","/tags/%E8%A1%A8%E6%A0%BC/"]],"categories":[["资源","/categories/%E8%B5%84%E6%BA%90/"]],"content":"里面内容是我收录的一些资源链接 标题 链接 备注 【C++】C++11新增关键字详解  转载标签，未找到原文 【C++札记】C++17 if-constexpr 提高代码可读性  windows11强制安装教程 绕过win11安装限制TPM  手把手 windows terminal 美化，拥有王一博个性化的终端 - 知乎 (zhihu.com)  难得有一个讲美化很细的 一些破解软件教程网站  主要是jetbrains的 charlese激活码生成网站  直接一步正版 稳定好用的梯子  十分钟搞定pandas  只有pandas内的操作，没有和excel交互 思维导图，流程图绘制，很简单  个人免费 茶杯狐，找电影，电视剧的  欧乐影院，也是各种视频资源的  大部分都是免费资源 也是看视频的  网速一般 也是看视频的  网速应该也是一般 也是看视频的  D站，和B站互补的，B站找不到的资源可以这里翻  M站，和D站互补，优先找M站内容  实用FRIDA进阶：内存漫游、hook anywhere、抓包  肉丝姐的 PDF转换工具网站  国外的，可能要代理 Protobuf 终极教程  主要是和go交互的 浏览器状态监测网站  android抓包学习的整理和归纳  正则表达式分析工具  嗨正则  樱花动漫  需要代理，资源较全，和M站互补 九九漫画网  需要代理，韩国漫画 正则学习  入门神器，可以查询 直接把你想要的模板弄出来  通用模板可以在这里查询 崔大的学习平台  猿人学对外学习平台  网络者学习平台  果核剥壳  下载资源好地方 Nginx负载均衡配置及算法详解  风车动漫  网络好的时候不错的网站 在线之家  最新的速度不错的网站 linux crontab执行规则  很不错的解释网站 "},{"title":"【lite-tools】一个python包的使用目录","date":"2022-11-17T10:31:35.000Z","url":"/2022/11/17/litetools/","tags":[["python","/tags/python/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":" 这个包是我搞的 方便日常工作中一些重复代码或者需要绕弯的代码压缩版本 安装这里一般来说国内国外镜像都可以，不过我这个更新太随意了，有些时候国内镜像更新会慢几小时pip install lite-tools 如果有其他需求可以pip install lite-tools[all]不过这个all版本我没有搞完，没时间，哈哈哈 命令行版块这里我们可以直接 lite-tools -h获取一些详细的操作 如果遇到pip安装了之后 lite-tools还是命令行不可使用，那是你python的scripts目录不在环境变量里面,需要手动添加一下,因为不添加你的scrapy``feapder这些工具也不可以命令行使用，具体操作自己百度即可。 🧮 lite-tools fish这是一个人生日历，没有搞农历节日那些东西，所以这里是标准的上五休二制度 🧮 lite-tools say这里基于 熊与论道兽音 版块修改算法改成python版本后实现的，并做了智能识别，大概操作如下 新增了 morse –》 可以通过 lite-tools say -h 查看使用方法 🧮 lite-tools acg这里我没有弄好，主要是这里需要一个自动校准数据这里我没有弄，后面再弄，不复杂，想提前体验可以终端输入自己试一下 🧮 lite-tools news 这里默认是获取国内新闻 lite-tools news weibo 这样子可以获取此时此刻的微博热榜榜单 lite-tools news china/world后面跟china或者world可以获取此时此刻中国或者世界上的最新的新闻 lite-tools news paper 这个和直接输入lite-tools news效果一样，只不过这个数据源是澎湃新闻，默认是环球网 🧮 lite-tools today 默认获取今天的黄历，也可以获取今年的节假日，并看经过情况 lite-tools today history获取历史上的今天的信息 lite-tools today oil获取今天的油价 🧮 lite-tools dict全程通过输入对应的数字可以查找汉字的拼音，因为拼音你会打就会查，但是不会打的就可以尝试我这个看看。 🧮 lite-tools weather默认根据当前请求IP获取当地的天气，当然有可能请求失败，然后会默认返回北京的天气可以手动指定 **市区县 **然后获取对应地点的天气，后面不用写市区县，如下 lite-tools weather 天河 获取天河区的天气，如果全国有同名的区就不知道是哪个地方了lite-tools weather 广州 这样子就可以获取广州市的 🧮 lite-tools trans这里需要安装额外的包 pip install lite-tools[all]才可以实现以下功能。这里是比较复杂的，这里面很多功能我没有实现，目前我只搞了一个图片转pdf。**具体的操作可以看 ****lite-tools trans -h**这里-i或者--input后面必须要跟输入路径，这后面可以跟文件夹，也可以跟单个图片-o或者--output后面是输入文件的位置，这里可以定义输出文件的名称，不写默认同输入文件的名字示例:上面-i后面跟了这个文件夹路径 后面-o后面自定义了输出的文件名称 这里的-o要是不写后面输出的文件就是 和文件夹同名的一个pdf 这里有个问题，这里是一个图片一页纸 我没有做密度排版，那样子要做很多计算，太麻烦了，反正平时大多数图片都是一页一页的 代码里面使用📋 get_lan &#x2F; get_wan因为python自带的socket获取内网地址没有那么好用，我自己通过正则写了一个 📋 get_b64d &#x2F; get_b64e就是base64加解密 📋 try_get &#x2F; try_key &#x2F; FlattenJson &#x2F; WrapJson📋 try_get用jspath 的方法提取json串或者字典 注意事项 正常使用的话就不用看了 数组在前的时候不能不加. 作为分割 如a.b[1][2].c ，不能 写成a.b[1][2]c 有几个字符如果是键里面的元素的话，需要加上转义符号 符号有 . 、 [ 、 ]、 | 这四个是键的话要转义 如{&quot;a|b&quot;: [0, {&quot;c.d[]&quot;: 666}]} 解析需要写 a\\|b[1].c\\.d\\[\\] 如果要提取的键是整型或者浮点型就不要用我这个方法了 如 {6: {3.14: 666} 这种我的方法解析不了，主要是我懒得处理这些逻辑 还要判断写在字符串里面的内容是啥类型 📋 try_key这个结果是列表，因为可以匹配出来多个结果，通过一个键 来匹配多个值，或者一个确定的值 匹配它的键 📋 FlattenJson这里是扁平化json,就是把一个很大的json 可以变成一元的,然后也可以通过jspath的方法取值那些 📋 JsJson这个我没有搞完,反正大概意思就是从html啥的文本里提取json出来,目前这里没啥用 📋 WrapJson折叠json, 把一个很大的json或者字典按照想要的格式进行压缩 使用注意事项 WrapJson的使用注意点 ... 只适用于 基本类型str, int, float, bool 的模糊匹配, 数组类型的tuple, dict, list, set 不适用 如果是数组类型,必须指明,如上面c 的情况 如果获取结果的值和模板匹配不上 将会返回空数组类型 {} / [] 📋 get_md5 &#x2F; get_sha &#x2F; get_sha3这里没啥好说的 就是如命加密 都有可以指定类型的参数,直接看方法就知道转啥了 📋 get_time &#x2F; time_count &#x2F; time_range📋 get_time时间转换, 方法都可以组合使用 📋 time_count获取函数运行时间的装饰器 📋 time_range获取起止时间的时间戳范围 📋 try_catch捕获异常的装饰器, 支持同步和异步 📋 get_ua获取user-agent 真实版本号 📋 MySql &#x2F; MySqlConfig &#x2F; SqlString描述复杂 这是给我自己使用方便的 如果你们要用的话 最好用 MySqlConfig 配置了传入MySql创建一个属于自己的 可以设置返回值的类型 在配置文件里面 有一个 cursor参数 默认tuple,可以设置为dict ，这里是字符串哦. 下面所有的where 都可以写字典和字符串 字典只有等值, 字符串就是你想写啥规则就是啥规则 最新版本 去掉了 insert和update的batch的操作，全部统一到insert&#x2F;batch里面 api有改动 📋 match_case可以让你的if-else 更加好看 📋 CleanString可能不好用 就是清理字符串的字符的 📋 clean_html采用了米乐大佬的 usepy 的包实现的 📋 color_string返回一个有颜色的字符串 📋 x_timeoutTODO 需要兼容同步和异步,所以这里有问题,这个也是不可用的状态 📋 Singleton单例模式装饰器 📋 Buffer一个队列,配合V神的vthread使用有奇效, 如果一个地方设置name 对应的其它的都需要设置对应的name 📋count_lines统计文件行数 📋LiteLogFile创建一个日志记录 采用循环记录 同一个位置只会存在10000条最多 超了从0开始记录 在用户目录下.lite_tools/logs/xxx下面可以找到记录 js相关的TODO 主要是js里面 进制转换 比如36进制啥的 大部分代码由 小小白 提供 📋atob&#x2F; btoa base64功能📋to_string_2📋to_string_16📋to_string_36 📋xor 📋unsigned_right_shift 📋left_shift 📋 dec_to_bin同上面的 &gt;&gt;&gt; to_string_2 "},{"title":"【nps】记录一次内网穿透搭建隧道代理过程","date":"2022-11-17T10:26:14.000Z","url":"/2022/11/17/nps/","tags":[["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"工具选择目前市面上有很多这种工具，原理其实都差不多，这里我采用黑哥推荐的 nps github页面地址：点击这里 准备工作打开官网 官方文档地址 这里面其实写的都很详细，但是！！里面很多东西概念很模糊，不理解原理直接看官方文档的话，可能会浪费时间所以接下来我们就来理解理解~ 原理VPS 因为会一直换IP 没有对外使用的公网，所以VPS上面放的是客户端所以我们需要一台有公网的服务器来挂服务端 所以公网得有，还得开你要开的端口的安全组客户端和服务端保持链接，由服务端来进行分发原理大概如此，接下来就是一些简单的配置操作 配置公网服务器-服务端下载对应系统版本的服务包 然后解压出来，解压出来的东西是可以直接使用的话，如果你要修改配置，可以到conf目录下找到nps.conf然后在里面修改你想要修改的，这里我就只改web端的密码，其他的不作修改。然后在外面目录下有一个nps的可执行文件我们先按照官网的教程 nps install 然后 nps start（这个后台启动）或者直接 nps这样子可以看见日志，我这里直接用nps启动观察日志。![nps服务端启动]( (1).png)随后通过公网:端口访问web页面，登录上后 我们要做的事情很简单，在客户端位置，创建一个东西![新建客户端]( (2).png)创建好了后我们点项目前面的 +可以展开，下面会有一个客户端命令，这里就是要我们在vps服务器上面启动的东西![创建好客户端后]( (3).png) VPS-客户端这边很简单，我们要做的就是 如果要搭建http代理的话，我们在web端页面HTTP代理位置新增一个 ![网站新增客户端]( (4).png) vps首先得拨号，有网络才可以 直接执行上面说的客户端命令 ![vps上面启动命令]( (5).png) 如果出现这种就是链接成功了，这个时候web客户端位置会有链接信息 ![访问ok情况]( (6).png) 测试一下![测试一下代理]( (7).png)上面的账号密码就是上面新增客户端位置设置的，公网ip后面的端口是后面设置HTTP代理那里设置的开放的端口 推荐还是弄socket代理 配置很简单 只需要新建一个socket客户端就可以了 注意：只要是需要对接的端口，记住需要开放公网服务器的安全组端口，要不然没有网，现在服务器基本都是默认关闭了对应端口的. 内网搭建API适合需求有些时候我们在内网服务器搭建了一个服务，但是我们想让其他人访问，这时候就可以通过这里下面的方案进行别人走一个公网，然后让别人访问到我们要访问的api啥的 web端配置第一步我们要在客户端那里建立一个服务，现在这里不要设置账号密码了别忘记在内网服务器也得执行一个那个**+号**下面的那个命令客户端保持连接哦，如果用了之前的，那么就不用了 第二步我们这次要在TCP隧道位置创建一个服务![TCP隧道测试]( (8).png) 服务部署在内网部署一个服务然后在外面通过公网访问测试一下，ok就没有问题啦"},{"title":"【chfs】文件共享服务搭建","date":"2022-11-17T10:19:05.000Z","url":"/2022/11/17/chfs/","tags":[["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"构建局域网内文件共享是不是经常忍受不了windows服务器的协议问题，加密又不方便，又不好操作呢？ 现在我们用一个工具 chfs 搭建一个局域网或者公网(你得有服务器)都可以使用的基于浏览器就可以访问的磁盘共享工具啦这里我们选用的工具官网是 点击这里 网站很简陋，因为要实现的功能很简单，操作也比较简单 windows局域网直接在这个网站上面下载我这里是2.0版本的直接下载链接 gui-chfs-windows.zip然后解压后得到一个exe文件,双击运行即可，然后在主目录有一个设置共享目录的，默认了这个压缩包解压的位置，可以修改需要共享的目录。当然用这个app的情况下，下次重启电脑后 你再打开这个软件，配置信息可能会丢失，所以，我们这里更加推荐下面的命令行部署方式，如果不限制很细的话，直接用这个即可 服务器部署 下面只负责能直接命令行启动 具体部署由你安排 第一步还是去网站下载对应版本的软件这里我下载的是linux版本，其它版本是一样的，在这里可以找到对应你服务器的版本 第二步然后把它解压出来，里面会有一个文件如果按照官方的教程，是可以很轻松的就部署的但是我们要使用配置文件的方案，这样子可以把配置都记录下来 第三步我这里放到服务器一个位置 第一步我们先给这个文件一个可执行的权限 第二步我们直接创建一个空文件的配置文件 config.ini 官方的教程 help: 显示帮助信息 path: 你要共享的目录，默认为程序运行目录。如果需要共享多个目录，则用“&#124;”符号隔开。注意：如果路径带有空格，则需要将整个路径用引号包住。 port: 程序使用的端口号，默认为80 allow: IP地址过滤，可使用白名单模式或黑名单模式 rule: 账户及访问权限，允许一个账户多点登陆，默认情况下匿名用户具有读写权限，其语法为： RULEITEM1[&#124;RULEITEM2&#124;RULEITEM3…] 每个RULEITEM代表一个账户信息及其访问权限，多个RULEITEM则用’&#124;’进行分割，RULEITEM的语法为： USER:PWD:MASK[:DIR:MASK…] 每个项由“:”来分隔，前三个项是必须的，分别对应：账户名、账户密码、共享目录根目录的访问权限。后面的可选的项，必须成对出现，用来设定根目录下面的子级目录的访问权限。一些规定： 对于匿名用户，前两个项都为空 访问权限分为四种：””(不可访问)，”R”(只读)，”W”(读写)，”D”(写+删除)。读权限指的是下载，写权限指上传、新建等操作，删除权限是在写权限的基础上加上删除权限。 各项的值应避免出现空白键，’:’及’&#124;’（目录名除外） || log: | 用户操作日志存放目录，默认是程序所在目录下的logs中。禁用日志功能只需将其赋值为空即可。 || file: | 配置文件，该文件可配置上述配置项，语法相同，如果配置有效则覆盖对应配置项。另外，一些功能需要通过配置文件进行配置，比如页面自定义和SSL证书设置。 || version: | 显示程序版本号 | 我们这里可见，官方的教程写的是很复杂的，特别是rule这一块，然后我们直接按行输入我们要配置的，这里先看看我这里的配置 配置详解 html.title这个就是设置网页标签的名称 html.notice这里是设置行首的，这里可以写html 可以用 “&#96;” 这个符号包裹住 port对外开放的端口 path共享的目录，多个共享目录的话可以用|进行分割 rule这个是配置权限规则的，默认是匿名用户可以拥有读写权限，我上面写了两个用户 ::这个意思就是匿名用户拥有根目录的读写权限 :::pic:r:com:r我这里是匿名用户对根目录没有读写权限，对pic目录和com目录有读权限，这里pic和com都是根目录下面的子目录 username:userpass:rwd这里是用户名为username密码为userpass对根目录有读写删权限 username:userpass::pic:r:com:rw这里是用户对根目录没有读写权限，对pic目录有读权限，对com目录有读写权限 allow这里是白名单和黑名单的设置 log这里可以配置日志存放的目录，如果不配置，默认当前文件所在目录(如果你用了配置文件不写也不会有日志,命令行启动会这样) 其它配置比如证书啥的都必须放在配置文件里面这里自己看官网教程 挂载服务这个自己安排上面是我展示的配置执行后显示的情况 无网情况 你服务器没有开对应端口的安全组，基本都是这个问题啦 暂时没有想到 "}]